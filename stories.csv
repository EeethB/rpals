uname,story,story_time,file_type
edgedata,"# EDGE DIY Data

<!-- badges: start -->
[![Travis build status](https://travis-ci.org/EeethB/edgedata.svg?branch=main)](https://travis-ci.org/EeethB/edgedata)
<!-- badges: end -->
",2022-07-07T18:11:24Z,.md
edgedata,"## Installation

`edgedata` can be installed from CRAN:

```
install.packages(""edgedata"")
```

You can also get the development version from Github:

```
remotes::install_github(""EeethB/edgedata"")
```

Specific versions can be installed from Github using their tags. For example, the final version using 2019 coefficients is `v0.1.0`:

```
remotes::install_github(""EeethB/edgedata@v0.1.0"")
```

See below for a table of versions corresponding to benefit years.
",2022-07-04T12:18:31Z,.md
edgedata,"## Summary

An R package containing the data that supports the CMS External Data Gathering Environment (EDGE) Server DIY algorithm
",2022-07-07T08:01:26Z,.md
edgedata,"## Background

When the Patient Protection and Affordable Care Act (PPACA, often just ACA, or Obamacare) was passed, health insurance issuers could no longer vary individual or small group premiums at the individual or group level due to risk. Thus if an issuer attracted greater than average risk, they would have to raise premiums for their entire individual and/or small group block, which would then push healthier members away, further increasing premiums. This is known as adverse selection.

The risk adjustment (RA) program was implemented to mitigate the risk of adverse selection. In RA, issuers with lower than average risk are required to transfer funds to issuers with higher than average risk. The total money transferred is budget-neutral so that there will always be enough money for the transfers. In order to calculate relative risk, issuers need a way to submit their enrollment, premium, and claims data to the federal government.

The Centers for Medicare and Medicaid Services (CMS) requires that issuers maintain an External Data Gathering Environment (EDGE) Server for RA. Data on the EDGE Servers is used to ultimately calculate the RA transfer payments. In order for issuers to QA EDGE submissions and to have a more transparent process to troubleshoot, CMS provides the EDGE DIY software, which allows issuers to calculate their risk score separately from the normal EDGE process.

The software is provided only in SAS format, and this package is the start of implementing it in R. This package provides the datasets used to support the DIY software.
",2022-07-06T07:09:33Z,.md
edgedata,"## Versions

Each new benefit year comes with a minor version update, and intra-year updates will typically get a patch version update:

| Benefit Year | Tag    |
| ------------ | ------ |
| 2019         | v0.1.0 |
| 2020         | v0.2.0 |
| 2021         | v0.3.0 |
",2022-07-03T22:17:08Z,.md
rpals_docs,"![](www/rpals_logo.png)
",2022-07-07T01:49:15Z,.md
rpals_docs,"# Stories are here for RStudio! :tada:

Inspired by Ben Awad's [VS Code Stories](https://github.com/ide-stories/vscode-stories) (And because people sharing code makes me happy :blush:), Rpals seeks to be an ultra-low-barrier-to-entry space for people to share their code with the R :earth_africa:

If you like Rpals and would like to support its development, you can

[![""Buy Me A Coffee""](https://www.buymeacoffee.com/assets/img/custom_images/orange_img.png)](https://www.buymeacoffee.com/EeethB)
",2022-07-05T10:24:27Z,.md
rpals_docs,"## Installation

I haven't even made this a package yet, so you can play around with Rpals by downloading or cloning this repository and running app2.R with RStudio. It is designed to be run from RStudio and viewed in the Viewer pane. It may break if run in other ways :shrug:
",2022-07-06T02:39:20Z,.md
rpals_docs,"## Current state

Rpals currently has a very rough, mostly functional UI. The bulk of the UI layout is there, but it needs some re-arranging and a bunch of styling. I want it to have some :sparkles: flair :sparkles:
",2022-07-04T21:05:54Z,.md
rpals_docs,"## MVP

I think the only thing left to reach a minimal UI is adding a way to actually share your code. Right now you can only read in code from the shared code table I made up. I think at least a ""share from clipboard"" and a ""share from current file"" would be good

Minimal backend might just be dropping CSVs into an S3 bucket for now. My biggest concern here will be auth. Can I create an ""rpals"" user in AWS who only has read and write access, but not drop access? Since this is going to be distributed as an add-in, not a hosted app, anyone who downloads it will be able to see the S3/DB interaction code and could theoretically use it to mess with my storage system, I think :unamused: So that seems not great
",2022-07-07T22:54:31Z,.md
rpals_docs,"## Future state

Future state is the biggest mess of the whole project! :laughing: I have all kinds of ideas with vastly different scopes, including, but not limited to:

1.  Curated pals list rather than feed of all users
2.  Text and video chatting? I want this to connect people!
3.  Plush toys! (And other merch) Some kind of ""hugging Rs"" where you keep one and send one to a pal
4.  Styling: I want the whole app to channel the energy of the logo - Soft, round, bright, and happy! But I currently don't know nearly enough CSS to pull this off
",2022-07-06T16:36:30Z,.md
rpals_funcs,"action_button_gt <- function(value, inputid, ts, ...) {
  as.character(shiny::actionLink(paste0(value, inputid, ts),
                                   ...)) %>%
    gt::html()
}",2022-07-03T15:15:36Z,.R
rpals_funcs,"
read_user_story <- function(uname, ts) {
  readr::read_csv(""stories.csv"") %>% 
    dplyr::filter(uname == uname, story_time == lubridate::ymd_hms(ts)) %>% 
    purrr::pluck(""story"")
}",2022-07-05T20:09:58Z,.R
rpals_funcs,"
open_user_file <- function(text, user, file_ext, session_temp_dir) {
  file_path <- stringr::str_glue(""{session_temp_dir}\\\\@{user}{file_ext}"")
  
  readr::write_file(text, file_path)
  
  rstudioapi::navigateToFile(file_path)
}",2022-07-07T21:18:36Z,.R
rpals_funcs,"
read_pals <- function() {
  readr::read_csv(""pals.csv"")
}",2022-07-03T18:37:33Z,.R
rpals_funcs,"
read_stories <- function(story_index) {
  readr::read_csv(""stories.csv"") %>%
    dplyr::arrange(desc(story_time)) %>% 
    dplyr::slice((story_index * 5 - 4):(story_index * 5))
}",2022-07-07T04:21:06Z,.R
rpals_funcs,"
read_creds <- function() {
  readr::read_csv(""creds.csv"")
}",2022-07-04T08:35:27Z,.R
rpals_funcs,NA,2022-07-05T12:23:49Z,.R
eeethb,"      file_ext <- dplyr::if_else(
        input$file_type == ""Other"",
        input$file_ext_other,
        df_file_types %>% 
          dplyr::filter(file_type == input$file_type) %>% 
          purrr::pluck(""file_ext"")
      )",2022-08-09T03:37:40Z,.R
eeethb,"library(magrittr)

source(""utils.R"")
source(""read_data.R"")

# Define server logic required to draw a histogram
shinyServer(function(input, output, session) {
  # Auth ----------------------------------------------------------------------
  credentials <- shinyauthr::loginServer(
    id = ""login"",
    data = df_creds,
    user_col = user,
    pwd_col = password,
    log_out = shiny::reactive(logout_init())
  )
  
  logout_init <- shinyauthr::logoutServer(id = ""logout"",
                                          active = shiny::reactive(credentials()$user_auth))
  
  output$welcome_user <- shiny::renderUI({
    req(credentials()$user_auth)
    
    shiny::em(paste0(""Welcome @"", credentials()$info$user))
    
  })
  
  # Other ---------------------------------------------------------------------
  stories_index <- 0
  
  df_stories <- shiny::eventReactive(input$refresh_stories, {
    stories_index <- stories_index + 1
    
    read_stories(stories_index) %>%
      dplyr::left_join(read_pals(), by = ""uname"") %>%
      dplyr::mutate(button = purrr::map2(
        .x = uname,
        .y = stringr::str_replace_all(story_time, ""[[:punct:]|[:space:]]"", ""_""),
        .f = ~ action_button_gt(
          .x,
          ""_story_"",
          .y,
          label = fontawesome::fa(""far fa-file-code"",
                                  stroke = ""grey"",
                                  height = ""30px"")
        )
      ))
    
  })
  
  # Render pals gt, including subbing in PFPs ---------------------------------
  output$stories <- gt::render_gt({
    gt::gt(df_stories()) %>%
      gt::text_transform(
        locations = gt::cells_body(columns = c(""pic"")),
        fn = function(x) {
          paste0(""<img id="", x, "" src="", x, "" height=30px></img>"")
        }
      ) %>%
      gt::cols_hide(c(file_type, story, story_time)) %>%
      gt::cols_move(c(uname, name, button), after = pic)
    
  })
  
  # Apply an onclick method to the `button` column in the stories gt ----------
  shiny::observe({
    purrr::pwalk(
      .l = dplyr::select(df_stories(), uname, story_time, file_type),
      .f = ~ shinyjs::onclick(
        id = paste0(
          ..1,
          ""_story_"",
          stringr::str_replace_all(..2, ""[[:punct:]|[:space:]]"", ""_"")
        ),
        expr = {
          story <- read_user_story(..1, ..2)
          open_user_file(story, ..1, ..3, tempdir())
        }
        
      )
      
    )
    
  })
  
  # Render story inputs only after successful auth ----------------------------
  output$story_inputs <- shiny::renderUI({
    req(credentials()$user_auth)
    
    shiny::tagList(
      shiny::selectInput(
        ""file_type"",
        ""File Type"",
        c(""R"", ""Python"", ""SQL"", ""Markdown"", ""RMarkdown"", ""Other""),
        selected = ""R""
      ),
      
      shiny::textInput(
        ""file_ext_other"",
        ""Other File Extension"",
        placeholder = "".sas""
      ),
      
      shiny::actionButton(
        ""story_current"",
        ""Story from current script"",
        icon = shiny::icon(""far fa-file-code"")
      ),
      
      shiny::actionButton(
        ""story_clip"",
        ""Story from Clipboard"",
        icon = shiny::icon(""far fa-clipboard-list"")
      ),
      
      # shiny::fileInput(""story-file"")
      
    )
    
  })
  
  # Create a story actions ----------------------------------------------------
  shiny::observeEvent(
    input$story_current,
    {
      text <- rstudioapi::getSourceEditorContext() %>%
        purrr::pluck(""contents"") %>%
        paste(collapse = ""\n"")
      
      file_ext <- dplyr::if_else(
        input$file_type == ""Other"",
        input$file_ext_other,
        df_file_types %>%
          dplyr::filter(file_type == input$file_type) %>%
          purrr::pluck(""file_ext"")
      )
      
      story_entry <- tibble::tibble(
        uname = credentials()$info$user,
        story = text,
        story_time = lubridate::now(""UTC""),
        file_type = file_ext
      )
      
      readr::write_csv(story_entry, ""stories.csv"", append = TRUE)
      
    }
  )
  
  shiny::observeEvent(
    input$story_clip,
    {
      text <- clipr::read_clip(allow_non_interactive = TRUE) %>%
        paste(collapse = ""\n"")
      
      file_ext <- dplyr::if_else(
        input$file_type == ""Other"",
        input$file_ext_other,
        df_file_types %>%
          dplyr::filter(file_type == input$file_type) %>%
          purrr::pluck(""file_ext"")
      )
      
      story_entry <- tibble::tibble(
        uname = credentials()$info$user,
        story = text,
        story_time = lubridate::now(""UTC""),
        file_type = file_ext
      )
      
      readr::write_csv(story_entry, ""stories.csv"", append = TRUE)
      
    }
    
  )
  
})
",2022-08-16T02:33:48Z,.R
